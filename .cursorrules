# ComplyLight Core

This "core" library operates on FHIR and healthcare data to provide information sensitivity classification, security labeling, and redaction capabilities to higher-level applications in a modular and extensible manner.

As a TypeScript library published as an ESM (ES Module) package, the codebase emphasizes clean, reusable, and extensible patterns suitable for healthcare consent management, enforcement, and data exchange systems. It must be usable both within the browser as well as Node-based applications. Two such critical applications and checked out in:

- ../server - NodeJS API exposing capabilities of the core library via CDS-Hooks and REST APIs
- ../portal - User-facing SPA browser webapp written in Angular.
 
DO NOT AUTOMATICALLY COMMIT CHANGES TO GIT!

## TypeScript & ESM Module Standards

### Module System
- **Always use ESM syntax**: Use `import`/`export` statements, never `require()` or `module.exports`
- **Include `.js` extensions in imports**: When importing local files, always include the `.js` extension (TypeScript will resolve to `.ts` files)
- **Use explicit exports**: Prefer named exports over default exports for better tree-shaking and clarity
- **Barrel exports**: Use `index.ts` files to re-export related modules for clean public API

### Type Safety
- **Strict TypeScript**: The project uses `strict: true` - maintain strict type checking
- **Avoid `any`**: Use `unknown` when the type is truly unknown, then narrow with type guards
- **Use enums for constants**: Prefer enums over string literals for fixed sets of values
- **Type inference**: Use type inference for local variables when types are obvious, but be explicit for public APIs

### Code Organization
- **Modular structure**: Keep related functionality in dedicated directories
- **Single responsibility**: Each class/module should have a clear, single purpose
- **Abstract base classes**: Use abstract classes for extensible patterns (e.g., `AbstractDataSharingEngine`, `AbstractSensitivityRuleProvider`)
- **Interface segregation**: Prefer smaller, focused interfaces over large monolithic ones

## Code Quality & Reusability

### Design Patterns
- **Extensibility over modification**: Design classes to be extended rather than modified
- **Dependency injection**: Accept dependencies through constructors for testability and flexibility
- **Factory patterns**: Consider factory functions/classes for complex object creation
- **Strategy pattern**: Use abstract classes and interfaces to allow different implementations

### Code Style
- **Author attribution**: Include author comment at the top of new files: `// Author: [Name]`
- **Clear method names**: Method names should clearly describe what they do
- **Avoid magic values**: Extract constants and configuration values
- **Early returns**: Use early returns to reduce nesting and improve readability
- **Guard clauses**: Use guard clauses for validation and error cases

### Documentation
- **JSDoc for public APIs**: Add JSDoc comments for exported classes, methods, and complex logic
- **Inline comments**: Use comments to explain "why", not "what" (the code should be self-documenting)
- **TODO comments**: Mark incomplete work with `// TODO @username` format

## File Structure & Imports

### Export Strategy
- **Barrel exports**: Use `src/index.ts` to re-export public APIs
- **Avoid deep exports**: Prefer exporting from index files rather than deep import paths
- **Type exports**: Export types alongside implementations when they're part of the public API

## Testing Considerations
- **Testable code**: Write code that can be easily unit tested
- **Mock-friendly**: Design interfaces and abstract classes that can be easily mocked
- **Isolated modules**: Ensure modules can be tested independently

## Performance & Best Practices
- **Avoid premature optimization**: Write clear, maintainable code first
- **Efficient data structures**: Choose appropriate data structures for the use case
- **Memory management**: Be mindful of large data structures and consider streaming for large datasets

### Model Classes
- Use classes for domain models that have behavior
- Use interfaces/types for pure data structures
- Enums for fixed sets of related constants

## When Adding New Code
1. **Check existing patterns**: Look for similar code in the codebase and follow established patterns
2. **Consider reusability**: Can this be reused elsewhere? Should it be abstracted?
3. **Type everything**: Ensure all public APIs have explicit types
4. **Update exports**: Add new exports to `src/index.ts` if they're part of the public API
5. **Maintain consistency**: Follow the existing code style and structure

## Anti-Patterns to Avoid
- Using `any` without justification
- Mixing CommonJS (`require`) with ESM (`import`)
- Creating deep inheritance hierarchies (prefer composition)
- Tight coupling between modules
- Exposing internal implementation details in public APIs
- Mutating shared state without clear ownership


